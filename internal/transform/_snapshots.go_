package transform

import (
	"errors"
	"fmt"
	"math/big"

	"github.com/jackc/pgx/v5/pgtype"
	"github.com/stnokott/helldivers-client/internal/api"
	"github.com/stnokott/helldivers-client/internal/db"
	"github.com/stnokott/helldivers-client/internal/db/gen"
)

func Snapshot(data APIData, errFunc func(error)) (s *db.Snapshot) {
	s = &db.Snapshot{
		S: gen.Snapshot{},
		W: gen.WarSnapshot{},
		P: []db.PlanetSnapshot{},
		X: gen.SnapshotStatistic{},
	}

	snapshotSetWarID(s, data.WarID, errFunc)
	snapshotSetWar(s, data.War, errFunc)
	snapshotSetAssignments(s, data.Assignments, errFunc)
	snapshotSetCampaigns(s, data.Campaigns, errFunc)
	snapshotSetDispatches(s, data.Dispatches, errFunc)
	snapshotSetPlanets(s, data.Planets, errFunc)

	return
}

func snapshotSetWarID(snap *db.Snapshot, warID *api.WarId, errFunc func(error)) {
	if warID == nil || warID.Id == nil {
		errFunc(errors.New("got nil War ID, will be omitted"))
		return
	}
	snap.W.WarID = *warID.Id
}

func snapshotSetWar(snap *db.Snapshot, warPtr *api.War, errFunc func(error)) {
	if warPtr == nil {
		errFunc(errors.New("got nil War, snapshot timestamp will be omitted"))
		return
	}
	war := *warPtr
	if war.ImpactMultiplier == nil {
		errFunc(errFromNils(warPtr))
		return
	}
	snap.W.ImpactMultiplier = *war.ImpactMultiplier

	stats, err := makeWarStatistics(war.Statistics)
	if err != nil {
		errFunc(err)
		return
	}
	snap.X = *stats
}

func snapshotSetAssignments(snap *db.Snapshot, assignmentsPtr *[]api.Assignment2, errFunc func(error)) {
	if assignmentsPtr == nil {
		errFunc(errors.New("got nil Assignments slice, will be omitted"))
		return
	}
	assignments := *assignmentsPtr
	for _, assignment := range assignments {
		if assignment.Id == nil {
			errFunc(errors.New("got nil Assignment ID, will be omitted"))
			continue
		}
		snap.S.AssignmentIds = append(snap.S.AssignmentIds, *assignment.Id)
	}
}

func snapshotSetCampaigns(snap *db.Snapshot, campaignsPtr *[]api.Campaign2, errFunc func(error)) {
	if campaignsPtr == nil {
		errFunc(errors.New("got nil Campaigns slice, will be omitted"))
		return
	}
	campaigns := *campaignsPtr
	for _, campaign := range campaigns {
		if campaign.Id == nil {
			errFunc(errors.New("got nil Campaign ID, will be omitted"))
			continue
		}
		snap.S.CampaignIds = append(snap.S.CampaignIds, *campaign.Id)
	}
}

func snapshotSetDispatches(snap *db.Snapshot, dispatchesPtr *[]api.Dispatch, errFunc func(error)) {
	if dispatchesPtr == nil {
		errFunc(errors.New("got nil Dispatches slice, will be omitted"))
		return
	}
	dispatches := *dispatchesPtr
	for _, dispatch := range dispatches {
		if dispatch.Id == nil {
			errFunc(errors.New("got nil Dispatch ID, will be omitted"))
			continue
		}
		snap.S.DispatchIds = append(snap.S.DispatchIds, *dispatch.Id)
	}
}

func snapshotSetPlanets(snap *db.Snapshot, planetsPtr *[]api.Planet, errFunc func(error)) {
	if planetsPtr == nil {
		errFunc(errors.New("got nil Planets slice, will be omitted"))
		return
	}
	planets := *planetsPtr
	for _, planet := range planets {
		if planet.Index == nil ||
			planet.Health == nil ||
			planet.CurrentOwner == nil {
			errFunc(errFromNils(&planet))
			continue
		}
		eventSnapshot, err := makeEventSnapshot(planet.Event)
		if err != nil {
			errFunc(err)
			continue
		}

		planetStatistics, err := makePlanetStatistics(planet.Statistics)
		if err != nil {
			errFunc(err)
			continue
		}
		var attacking []int32
		if planet.Attacking != nil {
			attacking = *planet.Attacking
		}
		planetSnap := db.PlanetSnapshot{
			S: gen.PlanetSnapshot{
				PlanetID:           *planet.Index,
				Health:             *planet.Health,
				CurrentOwner:       *planet.CurrentOwner,
				EventSnapshotID:    nil, // will be filled later from DB
				AttackingPlanetIds: attacking,
				StatisticsID:       -1, // will be filled later from DB
			},
			E: eventSnapshot,
			X: *planetStatistics,
		}
		snap.P = append(snap.P, planetSnap)
	}
}

func makeEventSnapshot(eventPtr *api.Planet_Event) (*gen.EventSnapshot, error) {
	if eventPtr == nil {
		// events are optional, so nil is ok
		return nil, nil
	}
	planetEvent, err := eventPtr.AsEvent()
	if err != nil {
		return nil, fmt.Errorf("failed to parse Planet Event: %w", err)
	}
	if planetEvent.Id == nil || planetEvent.Health == nil {
		return nil, errFromNils(&planetEvent)
	}
	return &gen.EventSnapshot{
		EventID: *planetEvent.Id,
		Health:  *planetEvent.Health,
	}, nil
}

func makeStatistics(stats api.Statistics) (*gen.SnapshotStatistic, error) {
	if stats.MissionsWon == nil ||
		stats.MissionsLost == nil ||
		stats.MissionTime == nil ||
		stats.TerminidKills == nil ||
		stats.AutomatonKills == nil ||
		stats.IlluminateKills == nil ||
		stats.BulletsFired == nil ||
		stats.BulletsHit == nil ||
		stats.TimePlayed == nil ||
		stats.Deaths == nil ||
		stats.Revives == nil ||
		stats.Friendlies == nil ||
		stats.PlayerCount == nil {
		return nil, errFromNils(&stats)
	}

	return &gen.SnapshotStatistic{
		MissionsWon:     pgUint64(*stats.MissionsWon),
		MissionsLost:    pgUint64(*stats.MissionsLost),
		MissionTime:     pgUint64(*stats.MissionTime),
		TerminidKills:   pgUint64(*stats.TerminidKills),
		AutomatonKills:  pgUint64(*stats.AutomatonKills),
		IlluminateKills: pgUint64(*stats.IlluminateKills),
		BulletsFired:    pgUint64(*stats.BulletsFired),
		BulletsHit:      pgUint64(*stats.BulletsHit),
		TimePlayed:      pgUint64(*stats.TimePlayed),
		Deaths:          pgUint64(*stats.Deaths),
		Revives:         pgUint64(*stats.Revives),
		Friendlies:      pgUint64(*stats.Friendlies),
		PlayerCount:     pgUint64(*stats.PlayerCount),
	}, nil
}

func pgUint64(x uint64) pgtype.Numeric {
	return pgtype.Numeric{Int: new(big.Int).SetUint64(x)}
}

func makePlanetStatistics(statsPtr *api.Planet_Statistics) (*gen.SnapshotStatistic, error) {
	if statsPtr == nil {
		return nil, errors.New("got nil Planet Statistics")
	}
	stats, err := statsPtr.AsStatistics()
	if err != nil {
		return nil, fmt.Errorf("cannot parse Planet Statistics: %w", err)
	}
	return makeStatistics(stats)
}

func makeWarStatistics(statsPtr *api.War_Statistics) (*gen.SnapshotStatistic, error) {
	if statsPtr == nil {
		return nil, errors.New("got nil War Statistics")
	}
	stats, err := statsPtr.AsStatistics()
	if err != nil {
		return nil, fmt.Errorf("cannot parse War Statistics: %w", err)
	}
	return makeStatistics(stats)
}
